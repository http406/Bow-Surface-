<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bow Surface</title>
    <style>
        body { margin: 0; 
        background-color: black; 
        display: flex; 
        justify-content: center; 
        align-items: center; 
        height: 100vh;
        margin: 0; 
        outline: none;
        background: #000;
        -webkit-tap-highlight-color: transparent;
        }
        canvas { display: block; }
        #infoButton {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 20px;
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            user-select: none;
        }

        .info-popup {
            display: none;
            position: absolute;
            top: 40px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 5px;
            width: 300px;
            text-align: left;
            user-select: none;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <button id="infoButton">&#9432;</button>
    <div class="info-popup" id="infoPopup">
        <p style="text-align:center;" ><strong>Bow Surface</strong></p>
    <p style="color:pink; text-align: center;">The Bow Surface in this code refers to a 3D parametric surface, created using a mathematical equation that generates the shape of a surface resembling a "bow" (in terms of its curved, sweeping structure). In the context of your code, the Bow Surface is represented by the geometry generated by the THREE.ParametricGeometry in Three.js. This geometry is based on a parametric equation that determines the 3D coordinates (x, y, z) of each point on the surface, where the parameters are u and v.</p>
            <p style="text-align:center;">For Equations visit my Github. Enjoy!</p>
    </div>
    <script>
        let scene, camera, renderer;
        let bowSurface, stars;

        function init() {
            // Scene
            scene = new THREE.Scene();

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 14;

            // Renderer
            renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Space Background with Glittering Stars
            createSpaceBackground();

            // Bow Surface Geometry
            const geometry = new THREE.ParametricGeometry((u, v, target) => {
                const T = 1;
                u = u * 2 - 1;
                v = v * 2 - 1;
                target.x = 2 + T * Math.sin(2 * Math.PI * u) * Math.sin(4 * Math.PI * v);
                target.y = 2 + T * Math.sin(2 * Math.PI * u) * Math.cos(4 * Math.PI * v);
                target.z = T * Math.cos(2 * Math.PI * u) + 3 * Math.cos(2 * Math.PI * v);
            }, 100, 100);

            // Material
            const material = new THREE.MeshNormalMaterial({ wireframe: true });

            // Mesh
            bowSurface = new THREE.Mesh(geometry, material);
            scene.add(bowSurface);

            // Animation
            animate();
        }

        function createSpaceBackground() {
            const starGeometry = new THREE.BufferGeometry();
            const starMaterial = new THREE.PointsMaterial({ size: 0.5, vertexColors: true });

            const starsCount = 10000;
            const positions = [];
            const colors = [];

            for (let i = 0; i < starsCount; i++) {
                const x = Math.random() * 2000 - 1000;
                const y = Math.random() * 2000 - 1000;
                const z = Math.random() * 2000 - 1000;
                positions.push(x, y, z);

                // Assign random colors to stars
                const color = new THREE.Color(Math.random(), Math.random(), Math.random());
                colors.push(color.r, color.g, color.b);
            }

            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            starGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }

        function animate() {
            requestAnimationFrame(animate);

            // Rotation
            bowSurface.rotation.x += 0.01;
            bowSurface.rotation.y += 0.01;

            // Animate the glitter effect by slightly moving the stars
            stars.rotation.x += 0.0005;
            stars.rotation.y += 0.0005;

            renderer.render(scene, camera);
        }

        // Handle Window Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initialize
        init();
        
        $("#infoButton").click(function() {
            $("#infoPopup").fadeToggle();
        });
    </script>
</body>
      </html>
      
